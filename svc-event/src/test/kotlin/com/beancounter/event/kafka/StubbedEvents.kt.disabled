package com.beancounter.event.kafka

import com.beancounter.auth.AutoConfigureMockAuth
import com.beancounter.auth.MockAuthConfig
import com.beancounter.common.contracts.Payload.Companion.DATA
import com.beancounter.common.event.CorporateEvent
import com.beancounter.common.input.ImportFormat
import com.beancounter.common.input.TrustedEventInput
import com.beancounter.common.input.TrustedTrnEvent
import com.beancounter.common.model.Portfolio
import com.beancounter.common.model.SystemUser
import com.beancounter.common.model.TrnStatus
import com.beancounter.common.model.TrnType
import com.beancounter.common.utils.BcJson.Companion.objectMapper
import com.beancounter.common.utils.DateUtils
import com.beancounter.event.Constants.Companion.ALPHA
import com.beancounter.event.Constants.Companion.KMI
import com.beancounter.event.Constants.Companion.NZD
import com.beancounter.event.Constants.Companion.USD
import com.beancounter.event.contract.CorporateEventResponse
import com.beancounter.event.service.BackFillService
import com.beancounter.event.service.EventService
import com.beancounter.event.service.PositionService
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Tag
import org.junit.jupiter.api.Test
import org.mockito.Mockito
import org.mockito.kotlin.any
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.cloud.contract.stubrunner.spring.AutoConfigureStubRunner
import org.springframework.cloud.contract.stubrunner.spring.StubRunnerProperties
import org.springframework.cloud.stream.binder.test.OutputDestination
import org.springframework.security.oauth2.jwt.JwtDecoder
import org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors
import org.springframework.test.annotation.DirtiesContext
import org.springframework.test.context.ActiveProfiles
import org.springframework.test.context.bean.override.mockito.MockitoBean
import org.springframework.test.context.bean.override.mockito.MockitoSpyBean
import org.springframework.test.web.servlet.MockMvc
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post
import org.springframework.test.web.servlet.result.MockMvcResultMatchers.status
import java.math.BigDecimal

private const val EMAIL = "blah@blah.com"

/**
 * Test inbound Spring Cloud Stream corporate action events
 *
 * IMPORTANT: This test uses Spring Cloud Stream Test Binder instead of embedded Kafka.
 * This provides:
 * 1. Faster test execution (no broker startup)
 * 2. Broker-agnostic testing
 * 3. Simplified message verification
 *
 * Configuration:
 * - Uses "test" profile
 * - Spring Cloud Stream Test Binder for message capture
 * - Fixed stub runner ports: 11999 (svc-data), 12999 (svc-position)
 * - @DirtiesContext to ensure clean state between tests
 */

@AutoConfigureStubRunner(
    stubsMode = StubRunnerProperties.StubsMode.LOCAL,
    ids = [
        "org.beancounter:svc-data:0.1.1:stubs:11999",
        "org.beancounter:svc-position:0.1.1:stubs:12999"
    ]
)
@Tag("stream")
@SpringBootTest(
    properties = [
        "spring.cloud.stream.defaultBinder=test"
    ]
)
@ActiveProfiles("test")
@AutoConfigureMockMvc
@AutoConfigureMockAuth
@DirtiesContext
class StubbedEvents {
    @MockitoBean
    private lateinit var jwtDecoder: JwtDecoder

    @MockitoSpyBean
    private lateinit var eventService: EventService

    @MockitoSpyBean
    private lateinit var backfillService: BackFillService

    @Autowired
    private lateinit var mockAuthConfig: MockAuthConfig

    @Autowired
    private lateinit var mockMvc: MockMvc

    @Autowired
    private lateinit var outputDestination: OutputDestination

    @Autowired
    private lateinit var positionService: PositionService

    private val systemUser =
        SystemUser(
            id = EMAIL,
            email = EMAIL,
            true,
            since = DateUtils().getFormattedDate("2020-03-08")
        )

    @BeforeEach
    fun mockLogin() {
        mockAuthConfig.login()
    }

    var portfolio: Portfolio =
        Portfolio(
            id = "TEST",
            code = "TEST",
            name = "NZD Portfolio",
            currency = NZD,
            base = USD,
            owner = systemUser
        )
    val caDate = "2020-05-01"

    @Test
    fun is_NoQuantityOnDateNull() {
        val corporateEvent =
            CorporateEvent(
                id = null,
                trnType = TrnType.DIVI,
                recordDate = DateUtils().getFormattedDate(caDate),
                source = ALPHA,
                assetId = "MSFT",
                rate = BigDecimal("0.2625")
            )
        val trnEvent =
            positionService.process(
                portfolio,
                corporateEvent
            )
        assertThat(trnEvent.trnInput.trnType).isEqualTo(TrnType.IGNORE)
    }

    @Test
    fun is_DividendTransactionGenerated() {
        val corporateEvent =
            CorporateEvent(
                trnType = TrnType.DIVI,
                recordDate = DateUtils().getFormattedDate(caDate),
                source = ALPHA,
                assetId = KMI,
                rate = BigDecimal("0.2625")
            )
        val eventInput = TrustedEventInput(corporateEvent)
        val trnEvents = eventService.process(eventInput)
        assertThat(trnEvents).isNotNull.hasSize(1)

        // Check the message published to the output binding
        val message = outputDestination.receive(1000, "transactionEvent-out-0")
        assertThat(message).isNotNull
        verify(
            portfolio,
            trnEvents,
            message.payload
        )
        val events = eventService.forAsset(KMI)
        assertThat(events).hasSize(1)
        val (id) = events.iterator().next()
        val token = mockAuthConfig.getUserToken(systemUser)
        // Reprocess the corporate event
        val mvcResult =
            mockMvc
                .perform(
                    post("/$id")
                        .with(SecurityMockMvcRequestPostProcessors.jwt().jwt(token))
                ).andExpect(
                    status().isAccepted
                ).andReturn()

        val eventsResponse =
            objectMapper.readValue(
                mvcResult.response.contentAsString,
                CorporateEventResponse::class.java
            )
        assertThat(eventsResponse).isNotNull.hasFieldOrProperty(DATA)
        val message2 = outputDestination.receive(1000, "transactionEvent-out-0")
        verify(
            portfolio,
            trnEvents,
            message2.payload
        )

        mockMvc
            .perform(
                post("/backfill/${portfolio.id}/$caDate/$caDate")
                    .with(SecurityMockMvcRequestPostProcessors.jwt().jwt(token))
            ).andExpect(
                status().isAccepted
            ).andReturn()

        Thread.sleep(400)

        Mockito
            .verify(
                backfillService,
                Mockito.times(1)
            ).backFillEvents(
                portfolio.id,
                caDate,
                caDate
            )

        // Verify that the backfill request is dispatched, but not for cash
        Mockito
            .verify(
                eventService,
                Mockito.times(1)
            ).process(any())
    }

    // We're working with exactly the same event, so output should be the same
    private fun verify(
        portfolio: Portfolio,
        trnEvents: Collection<TrustedTrnEvent>,
        payload: ByteArray
    ) {
        assertThat(payload).isNotNull
        val received =
            objectMapper.readValue(
                payload,
                TrustedTrnEvent::class.java
            )
        val (portfolio1, importFormat, message, trnInput) = trnEvents.iterator().next()
        assertThat(portfolio1)
            .usingRecursiveComparison()
            .isEqualTo(portfolio)
        assertTrue(importFormat == ImportFormat.BC)
        assertThat(message).isEmpty()
        assertThat(received)
            .isNotNull
            .hasFieldOrProperty("trnInput")
            .hasFieldOrPropertyWithValue(
                "portfolio.id",
                portfolio1.id
            )
        assertThat(trnInput)
            .isNotNull
            .hasFieldOrPropertyWithValue(
                "trnType",
                TrnType.DIVI
            ).hasFieldOrPropertyWithValue(
                "status",
                TrnStatus.PROPOSED
            ).hasFieldOrPropertyWithValue(
                "tradeAmount",
                BigDecimal("14.70")
            ).hasFieldOrPropertyWithValue(
                "tax",
                BigDecimal("6.30")
            ).hasFieldOrPropertyWithValue(
                "quantity",
                BigDecimal("80.0")
            )
    }

    companion object {
        const val TRN_EVENT = "testTrnEvent"
        const val CA_EVENT = "testCaEvent"
    }
}